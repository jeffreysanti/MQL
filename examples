valgrind --tool=callgrind ./mql


clr
: sum { 0 ! __sum . for { __sum + ! __sum . } ->v . __sum }
[1,2,3,4,5] ->b sum
# 15

clr
: count { 0 ! __count . for { . 1 __count + ! __count } ->v . __count }
[1,2,3,4,5] ->b count
# 5

clr
: fib {
	dup dup
	0 = if {. . 0}
	else {1 = if {. 1}
	else {dup 1 - fib swap 2 - fib +}}
}
10 fib
# 55


clr
:filter2 { dup 1 %after if {} else . 1 %skip}
:even { filter2 { 2 MOD 0 = } }
[1,2,3,4,5,6,7,8,9,10] ->b even ->v
# 2,4,6,8,10


clr
:loop {1 swap range for { . 1 %afterr } ->v . 1 %skip }
5 loop { 'iter' @ . }
# 'iter' should be printed 5 times, and null on stack


clr
:five1 {1 buffer { dup 6 = if {. .} else {1 + 1} } }
five1 ->v
# 1,1,1,1,1



clr
:manip { 2 %insert {'abc'} 'd' 'e' 'f' 'g' 'h' 'i' + + + + + + }
# defabcghi
src manip
# After executing manip at least once:
# { 2.000000 %insert nop "d" "e" "f" "abc" nop "g" "h" "i" + + + + + + nop } 
# For reference, before:
src manip
#{ 2.000000 %insert 
#  { "abc" nop } 
# "d" "e" "f" "g" "h" "i" + + + + + + nop }

clr
:forinject { [1,2,3,4,5,6,7,8] ->b 0 1 insertt { . 0} for {dup mod 2 if { } else { }  } }

clr
:manipx { 2 %insertx {5 7 +} 'd' 'e' 'f' 'g' 'h' 'i' + + + + + + }
#'def12.000000ghi'
src manipx
# { 2.000000 %insertx nop "d" "e" "f" -/STACKDATA/- "g" "h" "i" + + + + + + nop }



clr
# Usage N repeat M => M,M,M, ... M (N times)
:repeat { 5 3 %inserttx {1 %afterr}  buffer { dup 1 = if {. .} else {1 - 1    nop } } 1 %skip}
10 repeat 0 ->v










